{"pageProps":{"postData":{"id":"根据已知坐标数组构造简单多边形","contentHtml":"<p><strong>问题</strong></p>\n<p>给定平面中n个点所组成的集合，将它们连接起来形成一条简单的封闭路径。所谓简单路径，是指边与边无交叉。</p>\n<p><strong>思路</strong></p>\n<p>取x坐标最大的点A（如果最大x坐标的点不止一个，则取Y坐标最小的点），依次计算A点与其余各点的连线与水平线之间夹角的正切值，然后按照正切值排序，依次连接排序后的各点即组成一个简单图形。</p>\n<p><strong>原理</strong></p>\n<p>其它所有点都在A点的左侧，所有夹角的范围为-Pi/2~Pi/2，单调递增函数。</p>\n<p><strong>代码实现</strong></p>\n<pre><code>// 经纬度坐标\nconst pointsList = [[95,30],[85,25],[99,23],[112,20],[108,13],[82,23]];\nfunction sortPolygonPoints (pointsList) {\n  // 获取最右侧的坐标（经度值最大）\n  let rightPoint = pointsList[0];\n  let maxLong = 0;\n  for (let i = 0; i &#x3C; pointsList.length; i++) {\n    const [long, _] = pointsList[i];\n    if (long > maxLong) {\n      maxLong = long;\n      rightPoint = pointsList[i];\n    }\n  }\n  // 定义数组存放坐标和对应正切值\n  const pointsArray = [];\n  for (let i = 0; i &#x3C; pointsList.length; i++) {\n    const [long, lat] = pointsList[i];\n    let tanX;\n    if (long === rightPoint[0] &#x26;&#x26; lat === rightPoint[1]) {\n      tanX = Number.MAX_SAFE_INTEGER;\n    } else {\n      tanX = (lat - rightPoint[1]) / (long - rightPoint[0]);\n    }\n    pointsArray.push({ point: pointsList[i], tanX });\n  }\n\n  pointsArray.sort((a, b) => a.tanX - b.tanX);\n  return pointsArray.map(({ point }) => point);\n}\nsortPolygonPoints(pointsList);\n</code></pre>\n<p>上述代码中<code>sortPolygonPoints</code>函数返回的数组各项依次连接，即可生成一个简单多边形。</p>\n","title":"根据已知坐标数组构造简单多边形","date":"2023-02-20"}},"__N_SSG":true}