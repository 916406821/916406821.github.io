{"pageProps":{"postData":{"id":"根据已知坐标数组构造简单多边形","contentHtml":"<p><strong>问题</strong></p>\n<p>给定平面中n个点所组成的集合，将它们连接起来形成一条简单的封闭路径。所谓简单路径，是指边与边无交叉。</p>\n<p><img src=\"https://raw.githubusercontent.com/shimiyzhang/blog-image/main/images/23-02-20/clipboard-5710.4c91b7.webp\" alt=\"\"></p>\n<p><strong>思路</strong></p>\n<p>取x坐标最大的点A（如果最大x坐标的点不止一个，则取Y坐标最小的点），依次计算A点与其余各点的连线与水平线之间夹角的正切值，然后按照正切值排序，依次连接排序后的各点即组成一个简单图形。</p>\n<p><strong>原理</strong></p>\n<p>其它所有点都在A点的左侧，所有夹角的范围为-Pi/2~Pi/2，单调递增函数。</p>\n<p><img src=\"https://raw.githubusercontent.com/shimiyzhang/blog-image/main/images/23-02-20/clipboard-3001.1ded24.webp\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/shimiyzhang/blog-image/main/images/23-02-20/clipboard-4069.de1ad0.webp\" alt=\"\"></p>\n<p><strong>代码实现</strong></p>\n<pre><code>// 经纬度坐标\r\nconst pointsList = [[95,30],[85,25],[99,23],[112,20],[108,13],[82,23]];\r\nfunction sortPolygonPoints (pointsList) {\r\n  // 获取最右侧的坐标（经度值最大）\r\n  let rightPoint = pointsList[0];\r\n  let maxLong = 0;\r\n  for (let i = 0; i &#x3C; pointsList.length; i++) {\r\n    const [long, _] = pointsList[i];\r\n    if (long > maxLong) {\r\n      maxLong = long;\r\n      rightPoint = pointsList[i];\r\n    }\r\n  }\r\n  // 定义数组存放坐标和对应正切值\r\n  const pointsArray = [];\r\n  for (let i = 0; i &#x3C; pointsList.length; i++) {\r\n    const [long, lat] = pointsList[i];\r\n    let tanX;\r\n    if (long === rightPoint[0] &#x26;&#x26; lat === rightPoint[1]) {\r\n      tanX = Number.MAX_SAFE_INTEGER;\r\n    } else {\r\n      tanX = (lat - rightPoint[1]) / (long - rightPoint[0]);\r\n    }\r\n    pointsArray.push({ point: pointsList[i], tanX });\r\n  }\r\n\r\n  pointsArray.sort((a, b) => a.tanX - b.tanX);\r\n  return pointsArray.map(({ point }) => point);\r\n}\r\nsortPolygonPoints(pointsList);\n</code></pre>\n<p>上述代码中<code>sortPolygonPoints</code>函数返回的数组各项依次连接，即可生成一个简单多边形。</p>\n<p>以上就是本文的全部内容，感谢阅读。</p>\n","title":"根据已知坐标数组构造简单多边形","date":"2023-02-20"}},"__N_SSG":true}