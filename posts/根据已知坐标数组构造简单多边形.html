<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/Z.svg"/><meta name="description" content="Welcome to Zhang Shumeng`s Blog"/><meta property="og:image" content="https://cdn.jsdelivr.net/gh/shimiyzhang/blog-image/images/23-02-24/clipboard-9882.d0bc97.webp"/><meta name="og:title" content="Zhang Shumeng`s Blog"/><meta name="twitter:card" content="summary_large_image"/><link rel="preload" as="image" href="/Z.svg"/><title>根据已知坐标数组构造简单多边形</title><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/0980fb410332472e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0980fb410332472e.css" data-n-g=""/><link rel="preload" href="/_next/static/css/3cf2d9b0cda59a28.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3cf2d9b0cda59a28.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-218004e7d27ded15.js" defer=""></script><script src="/_next/static/chunks/pages/_app-aef446c81fd4cad4.js" defer=""></script><script src="/_next/static/chunks/567-75104bd437223d69.js" defer=""></script><script src="/_next/static/chunks/327-84b3593cabc892c0.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-217addf3f9be560f.js" defer=""></script><script src="/_next/static/vuWUKuR4F6bQKL5o_3FYM/_buildManifest.js" defer=""></script><script src="/_next/static/vuWUKuR4F6bQKL5o_3FYM/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_container__fbLkO"><header class="layout_header__kY0Lt"><div style="position:fixed;top:0;left:0;height:.25rem;width:100%;background-color:rgb(99 102 241);transform:translateX(-100%);transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s"></div><a href="/"><img alt="Zhang Shumeng" width="108" height="108" decoding="async" data-nimg="1" class="utils_borderCircle__s2nTm" style="color:transparent" src="/Z.svg"/></a><h2 class="utils_headingLg__5535D"><a class="utils_colorInherit__mSH_x" href="/">Zhang Shumeng</a></h2></header><main><article><h1 class="utils_headingXl__u25Y2">根据已知坐标数组构造简单多边形</h1><div class="utils_lightText__eUzGY"><time dateTime="2023-02-20">2023年02月20日</time></div><div><p><strong>问题</strong></p>
<p>给定平面中n个点所组成的集合，将它们连接起来形成一条简单的封闭路径。所谓简单路径，是指边与边无交叉。</p>
<p><img src="https://raw.githubusercontent.com/shimiyzhang/blog-image/main/images/23-02-20/clipboard-5710.4c91b7.webp" alt=""></p>
<p><strong>思路</strong></p>
<p>取x坐标最大的点A（如果最大x坐标的点不止一个，则取Y坐标最小的点），依次计算A点与其余各点的连线与水平线之间夹角的正切值，然后按照正切值排序，依次连接排序后的各点即组成一个简单图形。</p>
<p><strong>原理</strong></p>
<p>其它所有点都在A点的左侧，所有夹角的范围为-Pi/2~Pi/2，单调递增函数。</p>
<p><img src="https://raw.githubusercontent.com/shimiyzhang/blog-image/main/images/23-02-20/clipboard-3001.1ded24.webp" alt=""></p>
<p><img src="https://raw.githubusercontent.com/shimiyzhang/blog-image/main/images/23-02-20/clipboard-4069.de1ad0.webp" alt=""></p>
<p><strong>代码实现</strong></p>
<pre><code>// 经纬度坐标
const pointsList = [[95,30],[85,25],[99,23],[112,20],[108,13],[82,23]];
function sortPolygonPoints (pointsList) {
  // 获取最右侧的坐标（经度值最大）
  let rightPoint = pointsList[0];
  let maxLong = 0;
  for (let i = 0; i &#x3C; pointsList.length; i++) {
    const [long, _] = pointsList[i];
    if (long > maxLong) {
      maxLong = long;
      rightPoint = pointsList[i];
    }
  }
  // 定义数组存放坐标和对应正切值
  const pointsArray = [];
  for (let i = 0; i &#x3C; pointsList.length; i++) {
    const [long, lat] = pointsList[i];
    let tanX;
    if (long === rightPoint[0] &#x26;&#x26; lat === rightPoint[1]) {
      tanX = Number.MAX_SAFE_INTEGER;
    } else {
      tanX = (lat - rightPoint[1]) / (long - rightPoint[0]);
    }
    pointsArray.push({ point: pointsList[i], tanX });
  }

  pointsArray.sort((a, b) => a.tanX - b.tanX);
  return pointsArray.map(({ point }) => point);
}
sortPolygonPoints(pointsList);
</code></pre>
<p>上述代码中<code>sortPolygonPoints</code>函数返回的数组各项依次连接，即可生成一个简单多边形。</p>
<p>以上就是本文的全部内容，感谢阅读。</p>
</div></article></main><div class="layout_backToHome__9sjx_"><a href="/">← 返回首页</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"根据已知坐标数组构造简单多边形","contentHtml":"\u003cp\u003e\u003cstrong\u003e问题\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e给定平面中n个点所组成的集合，将它们连接起来形成一条简单的封闭路径。所谓简单路径，是指边与边无交叉。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/shimiyzhang/blog-image/main/images/23-02-20/clipboard-5710.4c91b7.webp\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e思路\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e取x坐标最大的点A（如果最大x坐标的点不止一个，则取Y坐标最小的点），依次计算A点与其余各点的连线与水平线之间夹角的正切值，然后按照正切值排序，依次连接排序后的各点即组成一个简单图形。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原理\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e其它所有点都在A点的左侧，所有夹角的范围为-Pi/2~Pi/2，单调递增函数。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/shimiyzhang/blog-image/main/images/23-02-20/clipboard-3001.1ded24.webp\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/shimiyzhang/blog-image/main/images/23-02-20/clipboard-4069.de1ad0.webp\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e代码实现\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 经纬度坐标\nconst pointsList = [[95,30],[85,25],[99,23],[112,20],[108,13],[82,23]];\nfunction sortPolygonPoints (pointsList) {\n  // 获取最右侧的坐标（经度值最大）\n  let rightPoint = pointsList[0];\n  let maxLong = 0;\n  for (let i = 0; i \u0026#x3C; pointsList.length; i++) {\n    const [long, _] = pointsList[i];\n    if (long \u003e maxLong) {\n      maxLong = long;\n      rightPoint = pointsList[i];\n    }\n  }\n  // 定义数组存放坐标和对应正切值\n  const pointsArray = [];\n  for (let i = 0; i \u0026#x3C; pointsList.length; i++) {\n    const [long, lat] = pointsList[i];\n    let tanX;\n    if (long === rightPoint[0] \u0026#x26;\u0026#x26; lat === rightPoint[1]) {\n      tanX = Number.MAX_SAFE_INTEGER;\n    } else {\n      tanX = (lat - rightPoint[1]) / (long - rightPoint[0]);\n    }\n    pointsArray.push({ point: pointsList[i], tanX });\n  }\n\n  pointsArray.sort((a, b) =\u003e a.tanX - b.tanX);\n  return pointsArray.map(({ point }) =\u003e point);\n}\nsortPolygonPoints(pointsList);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述代码中\u003ccode\u003esortPolygonPoints\u003c/code\u003e函数返回的数组各项依次连接，即可生成一个简单多边形。\u003c/p\u003e\n\u003cp\u003e以上就是本文的全部内容，感谢阅读。\u003c/p\u003e\n","title":"根据已知坐标数组构造简单多边形","date":"2023-02-20"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"根据已知坐标数组构造简单多边形"},"buildId":"vuWUKuR4F6bQKL5o_3FYM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>